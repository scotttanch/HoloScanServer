import numpy as np


def parallel_curve(x_points, z_points, distance):
    """
    Generated by ChatGPT 3.5

    Generates a parallel curve in the xz plane at some specified distance.

    Args:
        x_points (list[float]): x coordinates defining the original curve
        z_points (list[float]): z coordinates defining the original curve
        distance (float): Distance from the original curve to the parallel curve

    Returns:
        (tuple[list[float], list[float]]): x and z cordinates of the parallel curve
    """

    # Convert x and y points to numpy arrays for vectorized operations
    x_array, z_array = np.array(x_points), np.array(z_points)

    # Compute differences between consecutive points to get tangent vectors
    dx, dz = np.diff(x_array), np.diff(z_array)

    # Compute normalized tangent vectors
    norm = np.sqrt(dx ** 2 + dz ** 2)
    norm[norm == 0] = np.inf
    normalized_tangents_x = dx / norm
    normalized_tangents_z = dz / norm

    # Rotate tangent vectors by 90 degrees to get normal vectors
    normals_x = normalized_tangents_z
    normals_z = -normalized_tangents_x

    # Scale normal vectors by the distance
    scaled_normals_x = normals_x * -distance
    scaled_normals_z = normals_z * -distance

    # Extend arrays for the last point
    scaled_normals_x = np.append(scaled_normals_x, scaled_normals_x[-1])
    scaled_normals_z = np.append(scaled_normals_z, scaled_normals_z[-1])

    # Generate points for parallel curve
    parallel_x_points = x_array + scaled_normals_x
    parallel_z_points = z_array + scaled_normals_z

    return parallel_x_points.tolist(), parallel_z_points.tolist()


def reduce_resolution(x_points, y_points, z_points, resolution=0.0, mean=False, endpoint=True):
    """
    Given a set of arbitrarily spaced points, reduce the minimum spacing between points.

    When the mean argument is set to true, points within the resolution radius are averaged together. This has the consequence of the
    set of points returned not being a subset of the orignal set.

    Args:
        x_points (list[float]): original x cordinates
        y_points (list[float]): original y cordinates
        z_points (list[float]): original z cordinates
        resolution (float): target for minimum spacing between points
        mean (bool): when False, all points within the resoltuion radius are discarded
        endpoint (bool): when True the last point in the original set is included regardless of its proximity to the previous point

    Returns:
        (tuple[list[float], list[float], list[float]]): x, y, and z corindates of the reduced set of points
    """

    # Raise a value error is our lists arent of equal length
    if not (len(x_points) == len(y_points) == len(z_points)):
        raise ValueError("Lists must be of equal length")

    new_x = []
    new_y = []
    new_z = []

    # This is just so pycharm will shut up about using a variable before I made it
    x_end = 0
    y_end = 0
    z_end = 0

    if endpoint:
        x_end = x_points[-1]
        y_end = y_points[-1]
        z_end = z_points[-1]

    # In mean mode, we average points within the resolution
    if mean:
        while x_points:
            x0 = x_points.pop(0)  # Pull the first point from the stacks
            y0 = y_points.pop(0)
            z0 = z_points.pop(0)
            x_in = [x0]
            y_in = [y0]
            z_in = [z0]
            while True and x_points:  # Make sure we dont try and pop more than we can
                d = np.sqrt((x_points[0] - x0) ** 2 + (y_points[0] - y0) ** 2 + (z_points[0] - z0) ** 2)
                if d < resolution:
                    x_in.append(x_points.pop(0))
                    y_in.append(y_points.pop(0))
                    z_in.append(z_points.pop(0))
                else:
                    break

            new_x.append(np.mean(x_in))
            new_y.append(np.mean(y_in))
            new_z.append(np.mean(z_in))

    # In non-mean mode we discard points within the resolutution radius, this ensures that the returned points
    # are a subset of the original points and not a new set entirely
    if not mean:
        while x_points:
            x0 = x_points.pop(0)  # Pull the first point from the stacks
            y0 = y_points.pop(0)
            z0 = z_points.pop(0)
            new_x.append(x0)
            new_y.append(y0)
            new_z.append(z0)
            while x_points:  # Make sure we dont try and pop more than we can
                d = np.sqrt((x_points[0] - x0) ** 2 + (y_points[0] - y0) ** 2 + (z_points[0] - z0) ** 2)
                if d < resolution:
                    x_points.pop(0)  # Pop and discard the point at the head
                    y_points.pop(0)  # Since it is in the radius we dont care about it
                    z_points.pop(0)  # except we might care about it if, if its the end point
                else:
                    break

    # If we care about the end point and thus saved it earlier, add the end point if needed
    if endpoint:
        if (new_x[-1] != x_end) and (new_y[-1] != y_end) and (new_z != z_end):
            new_x.append(x_end)
            new_y.append(y_end)
            new_z.append(z_end)

    return new_x, new_y, new_z


def interpolate_domain(xks, yks, zks, resolution):
    """
    Given some set of points creates a second set containing the orignal as well as points inbetween at some resolution.
    The disatance between each point may not be exactly the resolution due to the need to include the orinal points

    Args:
        xks (list[float]):
        yks (list[float]):
        zks (list[float]):
        resolution (float):

    Returns:
    """

    # Need to create a set of domain points
    internal_x = []
    internal_y = []
    internal_z = []

    # i goes from 0 to the number of points - 1 so the last point won't be used
    # so step i will give the points in the interval between antenna position i and i+1
    for i in range(len(xks) - 1):
        # find the distance between the two points and multiply by the resolution to get the number needed
        distance = np.sqrt(
            (xks[i] - xks[i + 1]) ** 2 +
            (yks[i] - yks[i + 1]) ** 2 +
            (zks[i] - zks[i + 1]) ** 2
        )

        num_points = round(distance / resolution)
        if num_points > 0:
            # generate the sub domains but dont use the end point because it will be the start of the next
            x_sub = np.linspace(xks[i], xks[i + 1], num_points, endpoint=False)
            y_sub = np.linspace(yks[i], yks[i + 1], num_points, endpoint=False)
            z_sub = np.linspace(zks[i], zks[i + 1], num_points, endpoint=False)
            internal_x.extend(x_sub)
            internal_y.extend(y_sub)
            internal_z.extend(z_sub)

        else:
            internal_x.append(xks[i])
            internal_y.append(yks[i])
            internal_z.append(zks[i])

    # add the end point on because it won't be included in the loop

    internal_x.append(xks[-1])
    internal_y.append(yks[-1])
    internal_z.append(zks[-1])

    return internal_x, internal_y, internal_z
