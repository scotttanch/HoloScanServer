import os

import numpy as np
from matplotlib.pyplot import imsave
from pandas import read_csv
from readgssi.dzt import readdzt

from flaskr.create_texture import create_textures
from flaskr.path_tools import reduce_resolution, parallel_curve

"""
    HoloScan object generation code for use with the HoloScan Server
    
    Author: Scott Tanch

    #### ------------------------------------------ Usage ------------------------------------------ #### 
        
        This module is designed to be used on data generated by the HardPack system in conjuction
        with the GSSI SIR-30. Unexpected behaviour may occur when trying to create HoloScans for 
        say, the AML.

    #### ------------------------------------ Reference Frames ------------------------------------- #### 

        
        Input data is saved in the RealSense Reference Frame (right-handed, x-forward, z-up)
        while Output data is in the Unity Reference Frame (left-handed, x-forward, y-up). 
        
    #### ------------------------------------------ Units ------------------------------------------ #### 

        All units are assumed to be in meters, which is the natural output of the Realsense
        and the input for Unity.
        
"""

MAX_PROC = 4


def read_position_data(file):
    """
    Reads a csv file whose first columns are x, y, z relative to the RealSense reference frame (right-handed z-up) and
    swaps to the Unity refernce frame (left-handed y-up).

    Args:
        file (str): name of the file being read

    Returns:
        (tuple[list[float], list[float], list[float]]): x, y, z cordinates in the Unity refernce frame

    """
    # TODO: This needs to be updated everytime I change how data is saved by the HardPack itself
    # csvs on the server are currently just x, y, z (RS Frame) -> x, z, y (Unity Frame)
    df = read_csv(file, header=None)
    xs, ys, zs = reduce_resolution(df[0].to_list(), df[2].to_list(), df[1].to_list(), resolution=0.05, endpoint=True)
    return xs, ys, zs


def create_geometry(x_points, y_points, z_points, depth):
    """
    Generates the nessicary mesh data for unity to render a surface composed of triangles. In SolidWorks terms, a line is extruded
    in the negative y direction to create a surface.

    Notes:
        For practical reasons, the mesh is actually comprised of two discojointed surfaces with flipped normal vectors,
        allowing it to be visable from both side. Suffice to say you can only see a triangle if its normal vector is
        pointing towards you.

        As another side note, the choice of format for the verts and uvs makes sense, each row a cordinate. One might notice
        that the tris are one value per row. This is a holdover from a processing choice in HoloScan3D and has no importance
        other than it is the way it is.

    Args:
        x_points (list[float]): original x points
        y_points (list[float]): original y points
        z_points (list[float]): original z points
        depth (float): depth to extrude the surface in the negative y-direction

    Returns:
        (tuple[list[str], list[str], list[str]]): vertexs, triangles, and uvs. These are formatted to be used by the writelines
        file operation
    """

    # From the original file, create two parallel paths at some offset
    pos_shift_x, pos_shift_z = parallel_curve(x_points, z_points, 0.001)
    neg_shift_x, neg_shift_z = parallel_curve(x_points, z_points, -0.001)

    pos_segments = [0]
    neg_segments = [0]

    # calculate the fraction along the file length of each point
    for i in range(1, len(pos_shift_x)):
        new_segment = np.sqrt((pos_shift_x[i] - pos_shift_x[i - 1]) ** 2 +
                              (pos_shift_z[i] - pos_shift_z[i - 1]) ** 2 +
                              (y_points[i] - y_points[i - 1]) ** 2)
        pos_segments.append(pos_segments[-1] + new_segment)

        new_segment = np.sqrt((neg_shift_x[i] - neg_shift_x[i - 1]) ** 2 +
                              (neg_shift_z[i] - neg_shift_z[i - 1]) ** 2 +
                              (y_points[i] - y_points[i - 1]) ** 2)
        neg_segments.append(neg_segments[-1] + new_segment)

    pos_tot = pos_segments[-1]
    neg_tot = neg_segments[-1]

    norm_pos_seg = [x / (2 * pos_tot) for x in pos_segments]
    norm_neg_seg = [x / (2 * neg_tot) for x in neg_segments]

    n = np.shape(x_points)[0]

    uvs = []
    for i in range(n):
        uvs.append(f"{0.5 + norm_pos_seg[i]},1\n")
    for i in range(n):
        uvs.append(f"{0.5 + norm_pos_seg[i]},0\n")
    for i in range(n):
        uvs.append(f"{0.5 - norm_neg_seg[i]},1\n")
    for i in range(n):
        uvs.append(f"{0.5 - norm_neg_seg[i]},0\n")

    verts = []
    for x, z, y in zip(pos_shift_x, pos_shift_z, y_points):
        verts.append(f"{x},{y},{z}\n")
    for x, z, y in zip(pos_shift_x, pos_shift_z, y_points):
        verts.append(f"{x},{y-depth},{z}\n")
    for x, z, y in zip(neg_shift_x, neg_shift_z, y_points):
        verts.append(f"{x},{y},{z}\n")
    for x, z, y in zip(neg_shift_x, neg_shift_z, y_points):
        verts.append(f"{x},{y-depth},{z}\n")

    tris = []
    for i in range(0, n - 2):
        tris.append(f"{i}\n")
        tris.append(f"{i + 1}\n")
        tris.append(f"{i + n + 1}\n")
        tris.append(f"{i}\n")
        tris.append(f"{i + n + 1}\n")
        tris.append(f"{i + n}\n")
    for i in range(2 * n, 3 * n - 2):
        tris.append(f"{i + n}\n")
        tris.append(f"{i + n + 1}\n")
        tris.append(f"{i}\n")
        tris.append(f"{i + n + 1}\n")
        tris.append(f"{i + 1}\n")
        tris.append(f"{i}\n")

    return verts, tris, uvs


def create_resources(folder_path):
    """
    Processes a single scan on the HoloScan server into mesh and texture files.

    Notes:
        folder path must be of the form './Survyes/PerkinsYard/090', and the folder must contain the files
        FILE____090.dzt and PATH____090.csv

    Args:
        folder_path (str): path to the folder being processed

    """

    # extract the scan number from folder_path
    scan_number = folder_path.rsplit(os.sep, maxsplit=1)[1]

    # construct the relevant file paths
    dzt_path = f"{folder_path}{os.sep}FILE____{scan_number}.DZT"        # Path to radar data
    positon_path = f"{folder_path}{os.sep}PATH____{scan_number}.csv"    # Path to position data
    st_texture_path = f"{folder_path}{os.sep}st.png"                    # Path for the standard texture
    rtt_texture_path = f"{folder_path}{os.sep}rtt.png"                  # Path for the reduced texture
    bp_texture_path = f"{folder_path}{os.sep}bpt.png"
    vert_path = f"{folder_path}{os.sep}verts.csv"                       # Path for mesh verticies
    tri_path = f"{folder_path}{os.sep}tris.csv"                         # Path for mesh triangles
    uv_path = f"{folder_path}{os.sep}uvs.csv"                           # Path for mesh uvs

    # It should not be possible to raise these errors but its always good to be safe
    if not os.path.exists(dzt_path):
        raise FileNotFoundError("DZT File Not Found")

    if not os.path.exists(positon_path):
        raise FileNotFoundError("Position File Not Found")

    # Extract radar and position data
    header, data, _ = readdzt(dzt_path)
    positions = read_position_data(positon_path)

    # Create the standard and reduced texture (only radar data dependant)
    
    standard, reduced = create_textures(header, data)
    abs_dzt = os.path.abspath(dzt_path)
    abs_csv = os.path.abspath(positon_path)
    abs_png = os.path.abspath(bp_texture_path)
    proc = MAX_PROC
    resolution = 0.01
    
    os.system(f"mpiexec -n {proc} python flaskr/create_backproject.py {abs_dzt} {abs_csv} {abs_png} {resolution}")
    
    # dzt_file and csv_file must be absolute paths
    # so os.path.abspath(dzt_path)
    # os.path.abspath(csv_path)
    # backproj = backproject(positions[0], positions[1], positions[2], header, data)

    # Create the mesh data (dependant on position data and max scan depth)
    verts, tris, uvs = create_geometry(*positions, header['rhf_depth'])

    # Write out mesh files
    with open(vert_path, "w") as f:
        f.writelines(verts)

    with open(tri_path, "w") as f:
        f.writelines(tris)

    with open(uv_path, "w") as f:
        f.writelines(uvs)

    # Save all three images
    imsave(st_texture_path, standard)
    imsave(rtt_texture_path, reduced)

    return


def test():
    create_resources("Testing\\081")

