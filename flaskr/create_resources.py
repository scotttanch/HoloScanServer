from readgssi.dzt import readdzt
from create_texture import create_textures
from matplotlib.pyplot import imsave
from pandas import read_csv
import numpy as np
import os

#


def parallel_curve(x_points, z_points, distance):
    """
    Generated by ChatGPT 3.5

    Generates a parallel curve at a specified distance from the original curve.

    Args:
        x_points (list): List of x coordinates defining the original curve.
        z_points (list): List of y coordinates defining the original curve.
        distance (float): Distance from the original curve to the parallel curve.

    Returns:
    tuple: Two lists, the first containing x coordinates and the second containing y coordinates
           defining the parallel curve.
    """

    # Convert x and y points to numpy arrays for vectorized operations
    x_array, z_array = np.array(x_points), np.array(z_points)

    # Compute differences between consecutive points to get tangent vectors
    dx, dz = np.diff(x_array), np.diff(z_array)

    # Compute normalized tangent vectors
    norm = np.sqrt(dx ** 2 + dz ** 2)
    norm[norm == 0] = np.inf
    normalized_tangents_x = dx / norm
    normalized_tangents_z = dz / norm

    # Rotate tangent vectors by 90 degrees to get normal vectors
    normals_x = normalized_tangents_z
    normals_z = -normalized_tangents_x

    # Scale normal vectors by the distance
    scaled_normals_x = normals_x * -distance
    scaled_normals_z = normals_z * -distance

    # Extend arrays for the last point
    scaled_normals_x = np.append(scaled_normals_x, scaled_normals_x[-1])
    scaled_normals_z = np.append(scaled_normals_z, scaled_normals_z[-1])

    # Generate points for parallel curve
    parallel_x_points = x_array + scaled_normals_x
    parallel_z_points = z_array + scaled_normals_z

    return parallel_x_points.tolist(), parallel_z_points.tolist()


def create_geometry(x_in, y_in, z_in, depth) -> tuple[list[str], list[str], list[str]]:

    # From the original path, create two parallel paths at some offset
    pos_shift_x, pos_shift_z = parallel_curve(x_in, z_in, 0.001)
    neg_shift_x, neg_shift_z = parallel_curve(x_in, z_in, -0.001)

    pos_segments = [0]
    neg_segments = [0]

    # calculate the fraction along the path length of each point
    for i in range(1, len(pos_shift_x)):
        new_segment = np.sqrt((pos_shift_x[i] - pos_shift_x[i - 1]) ** 2 +
                              (pos_shift_z[i] - pos_shift_z[i - 1]) ** 2 +
                              (y_in[i] - y_in[i - 1]) ** 2)
        pos_segments.append(pos_segments[-1] + new_segment)

        new_segment = np.sqrt((neg_shift_x[i] - neg_shift_x[i - 1]) ** 2 +
                              (neg_shift_z[i] - neg_shift_z[i - 1]) ** 2 +
                              (y_in[i] - y_in[i - 1]) ** 2)
        neg_segments.append(neg_segments[-1] + new_segment)

    pos_tot = pos_segments[-1]
    neg_tot = neg_segments[-1]

    norm_pos_seg = [x / (2 * pos_tot) for x in pos_segments]
    norm_neg_seg = [x / (2 * neg_tot) for x in neg_segments]

    n = np.shape(x_in)[0]

    uvs = []
    for i in range(n):
        uvs.append(f"{0.5 + norm_pos_seg[i]},1\n")
    for i in range(n):
        uvs.append(f"{0.5 + norm_pos_seg[i]},0\n")
    for i in range(n):
        uvs.append(f"{0.5 - norm_neg_seg[i]},1\n")
    for i in range(n):
        uvs.append(f"{0.5 - norm_neg_seg[i]},0\n")

    verts = []
    for x, z, y in zip(pos_shift_x, pos_shift_z, y_in):
        verts.append(f"{x},{y},{z}\n")
    for x, z, y in zip(pos_shift_x, pos_shift_z, y_in):
        verts.append(f"{x},{y-depth},{z}\n")
    for x, z, y in zip(neg_shift_x, neg_shift_z, y_in):
        verts.append(f"{x},{y},{z}\n")
    for x, z, y in zip(neg_shift_x, neg_shift_z, y_in):
        verts.append(f"{x},{y-depth},{z}\n")

    tris = []
    for i in range(0, n - 2):
        tris.append(f"{i}\n")
        tris.append(f"{i + 1}\n")
        tris.append(f"{i + n + 1}\n")
        tris.append(f"{i}\n")
        tris.append(f"{i + n + 1}\n")
        tris.append(f"{i + n}\n")
    for i in range(2 * n, 3 * n - 2):
        tris.append(f"{i + n}\n")
        tris.append(f"{i + n + 1}\n")
        tris.append(f"{i}\n")
        tris.append(f"{i + n + 1}\n")
        tris.append(f"{i + 1}\n")
        tris.append(f"{i}\n")

    return verts, tris, uvs


def read_position_data(path: str) -> tuple[list[float], list[float], list[float]]:
    df = read_csv(path, header=None)
    xs = df[0].to_list()
    ys = df[2].to_list()
    zs = df[1].to_list()
    # TODO: Implement some kind of smoothing on points being read in. Maybe step through and ignore any points less that some critical separation
    return xs, ys, zs


def create_resources(folder: str) -> None:

    # Lets assume that directory is somemthing like ./Survyes/PerkinsYard/090
    # and the folder contains the dzt named FILE____090.dzt and PATH____090.csv

    # To get the dzt and path name from the directory we just pull of the last segment
    scan_number = folder.rsplit(os.sep, maxsplit=1)[1]

    # Having these strings stored in variables will make it easier if i change what theyre supposed to be called later
    dzt_path = f"{folder}{os.sep}FILE____{scan_number}.DZT"
    positon_path = f"{folder}{os.sep}PATH____{scan_number}.csv"
    st_texture_path = f"{folder}{os.sep}st.png"
    rtt_texture_path = f"{folder}{os.sep}rtt.png"
    vert_path = f"{folder}{os.sep}verts.csv"
    tri_path = f"{folder}{os.sep}tris.csv"
    uv_path = f"{folder}{os.sep}uvs.csv"

    # These two paths should not be the same, thought they could be up to the extension if I got my shit together
    header, data, _ = readdzt(dzt_path)
    positions = read_position_data(positon_path)

    standard, reduced = create_textures(header, data)

    verts, tris, uvs = create_geometry(*positions, header['rhf_depth'])

    with open(vert_path, "w") as f:
        f.writelines(verts)

    with open(tri_path, "w") as f:
        f.writelines(tris)

    with open(uv_path, "w") as f:
        f.writelines(uvs)

    imsave(st_texture_path, standard)
    imsave(rtt_texture_path, reduced)

    return


# Example Usage
# create_resources('.\\Testing\\081')

# Resource Creation Steps
# 1. Read dzt file
# 2. Pass header and data to create_textures
# 3. Save textures
# 4. Read csv file
# 5. Pass header['depth'] and positions to mesh_generation
# 6. Save geometry files

