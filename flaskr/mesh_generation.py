import numpy as np


def parallel_curve(x_points, z_points, distance):
    """
    Generated by ChatGPT 3.5

    Generates a parallel curve at a specified distance from the original curve.

    Args:
    x_points (list): List of x coordinates defining the original curve.
    y_points (list): List of y coordinates defining the original curve.
    distance (float): Distance from the original curve to the parallel curve.

    Returns:
    tuple: Two lists, the first containing x coordinates and the second containing y coordinates
           defining the parallel curve.
    """
    # Convert x and y points to numpy arrays for vectorized operations
    x_array, z_array = np.array(x_points), np.array(z_points)

    # Compute differences between consecutive points to get tangent vectors
    dx, dz = np.diff(x_array), np.diff(z_array)

    # Compute normalized tangent vectors
    norm = np.sqrt(dx ** 2 + dz ** 2)
    norm[norm == 0] = np.inf
    normalized_tangents_x = dx / norm
    normalized_tangents_z = dz / norm

    # Rotate tangent vectors by 90 degrees to get normal vectors
    normals_x = normalized_tangents_z
    normals_z = -normalized_tangents_x

    # Scale normal vectors by the distance
    scaled_normals_x = normals_x * -distance
    scaled_normals_z = normals_z * -distance

    # Extend arrays for the last point
    scaled_normals_x = np.append(scaled_normals_x, scaled_normals_x[-1])
    scaled_normals_z = np.append(scaled_normals_z, scaled_normals_z[-1])

    # Generate points for parallel curve
    parallel_x_points = x_array + scaled_normals_x
    parallel_z_points = z_array + scaled_normals_z

    return parallel_x_points.tolist(), parallel_z_points.tolist()


def generate_mesh(org_x, org_y, org_z, y_width, folder):
    """
    Creates a mesh for unity from an initial set of cordinates representing a B-Scan survey path along with the maximum
    depth of that scan

    :return:
    """
    # From the original path, create two parallel paths at some offset
    pos_shift_x, pos_shift_z = parallel_curve(org_x, org_z,  0.001)
    neg_shift_x, neg_shift_z = parallel_curve(org_x, org_z, -0.001)

    pos_segments = [0]
    neg_segments = [0]

    # calculate the fraction along the path length of each point
    for i in range(1, len(pos_shift_x)):
        new_segment = np.sqrt((pos_shift_x[i] - pos_shift_x[i - 1]) ** 2 +
                              (pos_shift_z[i] - pos_shift_z[i - 1]) ** 2 +
                              (org_y[i] - org_y[i - 1]) ** 2)
        pos_segments.append(pos_segments[-1] + new_segment)

        new_segment = np.sqrt((neg_shift_x[i] - neg_shift_x[i - 1]) ** 2 +
                              (neg_shift_z[i] - neg_shift_z[i - 1]) ** 2 +
                              (org_y[i] - org_y[i - 1]) ** 2)
        neg_segments.append(neg_segments[-1] + new_segment)

    pos_tot = pos_segments[-1]
    neg_tot = neg_segments[-1]

    norm_pos_seg = [x / (2 * pos_tot) for x in pos_segments]
    norm_neg_seg = [x / (2 * neg_tot) for x in neg_segments]

    n = np.shape(org_x)[0]
    tris_folder = folder + "/tris.csv"
    verts_folder = folder + "/verts.csv"
    uvs_folder = folder + "/uvs.csv"
    with open(uvs_folder, "w") as f:
        for i in range(n):
            f.write(str(0.5 + norm_pos_seg[i]) + "," + str(1) + "\n")
        for i in range(n):
            f.write(str(0.5 + norm_pos_seg[i]) + "," + str(0) + "\n")
        for i in range(n):
            f.write(str(0.5 - norm_neg_seg[i]) + "," + str(1) + "\n")
        for i in range(n):
            f.write(str(0.5 - norm_neg_seg[i]) + "," + str(0) + "\n")

    with open(verts_folder, "w") as f:
        for x, z, y in zip(pos_shift_x, pos_shift_z, org_y):
            f.write(str(x) + "," + str(y) + "," + str(z) + "\n")
        for x, z, y in zip(pos_shift_x, pos_shift_z, org_y):
            f.write(str(x) + "," + str(y - y_width) + "," + str(z) + "\n")
        for x, z, y in zip(neg_shift_x, neg_shift_z, org_y):
            f.write(str(x) + "," + str(y) + "," + str(z) + "\n")
        for x, z, y in zip(neg_shift_x, neg_shift_z, org_y):
            f.write(str(x) + "," + str(y - y_width) + "," + str(z) + "\n")

    with open(tris_folder, "w") as f:
        for i in range(0, n - 2):
            f.write(str(i) + "\n")
            f.write(str(i + 1) + "\n")
            f.write(str(i + n + 1) + "\n")
            f.write(str(i) + "\n")
            f.write(str(i + n + 1) + "\n")
            f.write(str(i + n) + "\n")
        for i in range(2 * n, 3 * n - 2):
            f.write(str(i + n) + "\n")
            f.write(str(i + n + 1) + "\n")
            f.write(str(i) + "\n")
            f.write(str(i + n + 1) + "\n")
            f.write(str(i + 1) + "\n")
            f.write(str(i) + "\n")
    return
